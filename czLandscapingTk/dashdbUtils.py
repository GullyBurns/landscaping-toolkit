# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbdev/utils/06_dashsf.ipynb.

# %% auto 0
__all__ = ['Snowflake']

# %% ../nbdev/utils/06_dashsf.ipynb 4
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric import dsa
from cryptography.hazmat.primitives import serialization
import io
import os
import snowflake.connector
import pandas as pd
from enum import Enum
import re

class Snowflake():
  '''
  Class to provide simple access to Snowflake from within CZI

  Attributes (note - store `user`, `pem`, and `pwd` as `dbutils.secret` data ):
  * user: Snowflake username 
  * pem: SSH key 
  * pwd: Password for SSH key 
  * warehouse: name of the SNOWFLAKE warehouse
  * database: name of the SNOWFLAKE database
  * schema: name of the SNOWFLAKE schema
  * role: name of the SNOWFLAKE role with correct permissions to execute database editing
  '''

  def __init__(self, user, pem, pwd, warehouse, database, schema, role):
    self.user = user
    self.pem = pem
    self.pwd = pwd
    self.warehouse = warehouse
    self.database = database
    self.schema = schema
    self.role = role

    #string_private_key = f"-----BEGIN ENCRYPTED PRIVATE KEY-----\n{pem.strip()}\n-----END ENCRYPTED PRIVATE KEY-----"
    string_private_key = f"{pem.strip()}"

    p_key = serialization.load_pem_private_key(
        io.BytesIO(string_private_key.encode()).read(),
        password=pwd.strip().encode(),
        backend=default_backend())

    pkb = p_key.private_bytes(
        encoding=serialization.Encoding.DER,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption())

    self.ctx = snowflake.connector.connect(
        user=user.strip(),
        private_key=pkb,
        account='lr02922')

    cur = self.ctx.cursor()
    cur.execute("select current_date;")
    print(cur.fetchone()[0])

  def cursor(self):
    self.cs = self.ctx.cursor()
    return self.cs

  def get_cursor(self):
    '''
    Gets an active cursor for use within the database 
    '''
    cs = self.cursor()
    cs.execute('USE ROLE '+self.role)
    cs.execute('USE WAREHOUSE ' + self.warehouse)
    print('USE SCHEMA '+self.database+'.'+self.schema)
    cs.execute('USE SCHEMA '+self.database+'.'+self.schema)

    return cs

  def fetch_pandas(self, sql, batch=50000):
    cs = self.get_cursor()
    cs.execute(sql)
    rows = 0
    df = pd.DataFrame()
    while True:
        dat = cs.fetchmany(batch)
        if not dat:
          break
        cols = [desc[0] for desc in cs.description]
        df = pd.concat([df,pd.DataFrame(dat, columns=cols)])
        rows += df.shape[0]
    print(rows)
    return df

  def execute_query(self, cs, sql, columns):
    '''
    Executes an SQL query with a list of column names and returns a Pandas DataFrame
    '''    
    cs.execute(sql)
    df = pd.DataFrame(cs.fetchall(), columns=columns)
    df = df.replace('\n', ' ', regex=True)
    return df

  def run_query_in_spark(self, query):
    string_private_key = f"{self.pem.strip()}"

    p_key = serialization.load_pem_private_key(
        io.BytesIO(string_private_key.encode()).read(),
        password=self.pwd.strip().encode(),
        backend=default_backend())

    pkb = p_key.private_bytes(
      encoding = serialization.Encoding.PEM,
      format = serialization.PrivateFormat.PKCS8,
      encryption_algorithm = serialization.NoEncryption()
      )

    pkb = pkb.decode("UTF-8")
    pkb = re.sub("-*(BEGIN|END) PRIVATE KEY-*\n","",pkb).replace("\n","")

    # snowflake connection options
    options = dict(sfUrl="https://lr02922.snowflakecomputing.com/",
                   sfUser=self.user.strip(),
                   pem_private_key=pkb,
                   sfRole="ARST_TEAM",
                   sfDatabase=self.database,
                   sfSchema=self.schema,
                   sfWarehouse="DEV_WAREHOUSE")

    sdf = spark.read \
          .format("snowflake") \
          .options(**options) \
          .option("query", query) \
          .load()

    return sdf
